HttpHeaders h, 59 HttpResponse.BodySubscriber<?> userSubscriber, 60 Runnable onFinished) 61 { 62 this.pusher = userSubscriber; 63 this.contentLength = contentLength; 64 this.headers = h; 65 this.onFinished = onFinished; 66 this.dbgTag = connection.dbgString() + "/ResponseContent"; 67 } 68 69 static final int LF = 10; 70 static final int CR = 13; 71 72 private boolean chunkedContent, chunkedContentInitialized; 73 74 boolean contentChunked() throws IOException { 75 if (chunkedContentInitialized) { 76 return chunkedContent; 77 } 78 if (contentLength == -2) { 79 // HTTP/1.0 content 80 chunkedContentInitialized = true; 81 chunkedContent = false; 82 return chunkedContent; 83 } 84 if (contentLength == -1) { 85 String tc = headers.firstValue("Transfer-Encoding") 86 .orElse(""); 87 if (!tc.equals("")) { 88 if (tc.equalsIgnoreCase("chunked")) { 89 chunkedContent = true; 90 } else { 91 throw new IOException("invalid content"); 92 } 93 } else { 94 chunkedContent = false; 95 } 96 } 97 chunkedContentInitialized = true; 98 return chunkedContent; 99 } 100 101 interface BodyParser extends Consumer<ByteBuffer> { 102 void onSubscribe(AbstractSubscription sub); 103 // A current-state message suitable for inclusion in an exception 104 // detail message. 105 String currentStateMessage(); 106 } 107 108 // Returns a parser that will take care of parsing the received byte 109 // buffers and forward them to the BodySubscriber. 110 // When the parser is done, it will call onComplete. 111 // If parsing was successful, the throwable parameter will be null. 112 // Otherwise it will be the exception that occurred 113 // Note: revisit: it might be better to use a CompletableFuture than 114 // a completion handler. 115 BodyParser getBodyParser(Consumer<Throwable> onComplete) 116 throws IOException { 117 if (contentChunked()) { 118 return new ChunkedBodyParser(onComplete); 119 } else { 120 return contentLength == -2 121 ? new Http1_0BodyParser(onComplete) 122 : new FixedLengthBodyParser(contentLength, onComplete); 123 } 124 } 125 126 127 static enum ChunkState {READING_LENGTH, READING_DATA, DONE} 128 class ChunkedBodyParser implements BodyParser { 129 final ByteBuffer READMORE = Utils.EMPTY_BYTEBUFFER; 130 final Consumer<Throwable> onComplete; 131 final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG); 132 final String dbgTag = ResponseContent.this.dbgTag + "/ChunkedBodyParser"; 133 134 volatile Throwable closedExceptionally; 135 volatile int partialChunklen = 0; // partially read chunk len 136 volatile int chunklen = -1; // number of bytes in chunk 137 volatile int bytesremaining; // number of bytes in chunk left to be read incl CRLF 138 volatile boolean cr = false; // tryReadChunkLength has found CR 139 volatile int bytesToConsume; // number of bytes that still need to be consumed before proceeding 140 volatile ChunkState state = ChunkState.READING_LENGTH; // current state 141 volatile AbstractSubscription sub; 142 ChunkedBodyParser(Consumer<Throwable> onComplete) { 383 } else { 384 return true; // we're done! the final chunk was parsed. 385 } 386 } 387 388 private int toDigit(int b) throws IOException { 389 if (b >= 0x30 && b <= 0x39) { 390 return b - 0x30; 391 } 392 if (b >= 0x41 && b <= 0x46) { 393 return b - 0x41 + 10; 394 } 395 if (b >= 0x61 && b <= 0x66) { 396 return b - 0x61 + 10; 397 } 398 throw new IOException("Invalid chunk header byte " + b); 399 } 400 401 } 402 403 class Http1_0BodyParser implements BodyParser { 404 final Consumer<Throwable> onComplete; 405 final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG); 406 final String dbgTag = ResponseContent.this.dbgTag + "/Http1_0BodyParser"; 407 volatile Throwable closedExceptionally; 408 volatile AbstractSubscription sub; 409 volatile int breceived = 0; 410 411 Http1_0BodyParser(Consumer<Throwable> onComplete) { 412 this.onComplete = onComplete; 413 } 414 415 String dbgString() { 416 return dbgTag; 417 } 418 419 @Override 420 public void onSubscribe(AbstractSubscription sub) { 421 if (debug.on()) 422 debug.log("onSubscribe: " + pusher.getClass().getName()); 423 pusher.onSubscribe(this.sub = sub); 424 } 425 426 @Override 427 public String currentStateMessage() { 428 return format("http1_0 content, bytes received: %d", breceived); 429 } 430 431 @Override 432 public void accept(ByteBuffer b) { 433 if (closedExceptionally != null) { 434 if (debug.on()) 435 debug.log("already closed: " + closedExceptionally); 436 return; 437 } 438 boolean completed = false; 439 try { 440 if (debug.on()) 441 debug.log("Parser got %d bytes ", b.remaining()); 442 443 if (b.hasRemaining()) { 444 // only reduce demand if we actually push something. 445 // we would not have come here if there was no 446 // demand. 447 boolean hasDemand = sub.demand().tryDecrement(); 448 assert hasDemand; 449 breceived += b.remaining(); 450 pusher.onNext(List.of(b.asReadOnlyBuffer())); 451 } 452 } catch (Throwable t) { 453 if (debug.on()) debug.log("Unexpected exception", t); 454 closedExceptionally = t; 455 if (!completed) { 456 onComplete.accept(t); 457 } 458 } 459 } 460 461 /** 462 * Must be called externally when connection has closed 463 * and therefore no more bytes can be read 464 */ 465 public void complete() { 466 // We're done! All data has been received. 467 if (debug.on()) 468 debug.log("Parser got all expected bytes: completing"); 469 assert closedExceptionally == null; 470 onFinished.run(); 471 pusher.onComplete(); 472 onComplete.accept(closedExceptionally); // should be null 473 } 474 } 475 476 class FixedLengthBodyParser implements BodyParser { 477 final int contentLength; 478 final Consumer<Throwable> onComplete; 479 final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG); 480 final String dbgTag = ResponseContent.this.dbgTag + "/FixedLengthBodyParser"; 481 volatile int remaining; 482 volatile Throwable closedExceptionally; 483 volatile AbstractSubscription sub; 484 FixedLengthBodyParser(int contentLength, Consumer<Throwable> onComplete) { 485 this.contentLength =  = onComplete; 487 } 488 489 String dbgString() { 490 return dbgTag; 491 } 492 493 @Override 494 public void onSubscribe(AbstractSubscription sub) { 495 if (debug.on()) < prevĀ indexĀ next >